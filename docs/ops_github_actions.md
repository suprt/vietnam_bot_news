## GitHub Actions и эксплуатация

Этот документ описывает, как организован ежедневный запуск пайплайна новостей в GitHub Actions и какие настройки нужны.

### Общая идея

- Отдельный workflow, например `news_daily.yml`.
- Запуск по расписанию (раз в день) и при необходимости вручную.
- Внутри workflow:
  - `checkout` репозитория;
  - установка нужной версии Go;
  - запуск консольного приложения (`go run ./cmd/dailyjob` или аналогичный бинарь);
  - при использовании файлового состояния — возможный автокоммит изменений.

### Триггеры workflow

- `schedule` — ежедневный запуск по cron (например, рано утром по вьетнамскому времени).
- `workflow_dispatch` — ручной запуск из интерфейса GitHub.

Пример логики (конкретный cron будет выбран позже и зафиксирован в workflow):

- Запуск один раз в сутки для формирования «дайджеста дня».

### Секреты и переменные

**Важно:** Все токены и ключи API читаются приложением из переменных окружения. Они **никогда** не должны храниться в коде или конфиг-файлах репозитория.

**Настройка секретов в GitHub Actions:**
1. Перейдите в Settings → Secrets and variables → Actions
2. Добавьте следующие секреты:

**Обязательные секреты:**

- `GEMINI_API_KEY` — ключ для доступа к Gemini Flash (получить на https://ai.google.dev/)
- `TELEGRAM_BOT_TOKEN` — токен Telegram-бота (получить у @BotFather)

**Опциональные переменные окружения:**

- `FORCE_DISPATCH` — установите в `1` для принудительной рассылки даже при отсутствии новых новостей (удобно для тестирования)

**GitHub Token:**
- `GITHUB_TOKEN` автоматически доступен в GitHub Actions и используется для записи файла состояния обратно в репозиторий (если такая функциональность реализована).

**Пример настройки workflow:**
```yaml
- name: Run daily job
  env:
    GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
    TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
    FORCE_DISPATCH: ${{ github.event.inputs.force || '0' }}
  run: go run ./cmd/dailyjob
```

### Получатели Telegram

- В режиме `pipeline.auto_subscribe = true` список получателей не хранится в конфиге — он формируется автоматически.
- Процесс:
  1. Пользователь открывает диалог с ботом и отправляет `/start` (или любое сообщение).
  2. При следующем запуске пайплайна модуль Telegram читает `getUpdates`, фиксирует новый `chat_id` и сохраняет его в `state/state.json`.
  3. Со следующего прогона дайджест отправляется этому пользователю автоматически.
- Несколько пользователей могут подписаться независимо; один дайджест рассылается всем найденным `chat_id`.
- Чтобы протестировать отправку вручную, можно установить переменную окружения `FORCE_DISPATCH=1` (имя берётся из `pipeline.force_dispatch_env`) и запустить workflow через `workflow_dispatch`.

### Обработка ошибок и надёжность

- Базовый уровень:
  - при ошибке в работе приложения job помечается как failed, логи доступны в интерфейсе GitHub Actions.
- Ретраи:
  - при временных ошибках Gemini или Telegram рекомендуется реализовать несколько попыток на уровне кода (с задержками между ними);
  - при системных сбоях можно вручную перезапустить workflow (`workflow_dispatch`).
- Желательно предусмотреть:
  - отдельный Telegram-чат для алертов (например, отправка сообщения о критической ошибке, если дайджест не был сформирован).

### Работа с состоянием

**Что хранится в `state/state.json`:**
- `last_run` — время последнего запуска пайплайна
- `sent_articles` — список уже отправленных новостей (ID + дата), чтобы избежать дублирования между запусками
- `recipients` — список получателей Telegram (chat_id пользователей, которые подписались через бота)
- `telegram.last_update_id` — последний обработанный update ID от Telegram Bot API (чтобы не обрабатывать одни и те же апдейты дважды)

**Где создаётся файл:**
- В GitHub Actions рабочая директория — это корень репозитория (после `checkout`)
- Файл `state/state.json` создаётся в корне репозитория: `./state/state.json`
- При первом запуске, если файла нет, он будет создан автоматически

**Сохранение состояния между запусками:**
- По умолчанию файл обновляется только в рабочей директории GitHub Actions и **не коммитится автоматически**
- Чтобы сохранять состояние между запусками, нужно добавить в workflow шаг, который коммитит и пушит изменения:
  ```yaml
  - name: Commit state
    if: success()
    run: |
      git config user.name "github-actions[bot]"
      git config user.email "github-actions[bot]@users.noreply.github.com"
      git add state/state.json
      git diff --staged --quiet || (git commit -m "Update state" && git push)
  ```
- **Важно:**
  - избежать конфликтов с ручными изменениями (можно коммитить в отдельную ветку или использовать `[skip ci]` в сообщении коммита)
  - логика обновления состояния должна быть устойчивой к прерыванию job (частичный прогон не должен ломать файл)


